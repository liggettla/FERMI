#!/usr/bin/env python

# The purpose of this script is to create two fastq files that
# contain only those chunks of DNA that are of particular interest.

def runArgparse():
    import argparse
    parser=argparse.ArgumentParser()
    parser.add_argument('--indir', '-i', required=True, type=str, help='Specifies the input directory containing the input fastq files')
    parser.add_argument('--outdir', '-o', required=True, type=str, help='Specifies the output directory where the analysis should be put')
    parser.add_argument('--autogetsamples', '-a', action='store_true', help='This will try and automatically grab and sort all files in a specified input directory so they dont need to be manually specified. Samples should fit the pattern x1.fastq (r1) and x2.fastq (r2) where x can be any string.')

    args = parser.parse_args()

    return args.indir, args.outdir, args.autogetsamples

def autogetSamples(inputDir):
    print('Parsing Samples...')
    # this will attempt to automatically generate r1/r2 pairs
    from glob import glob as g
    from os.path import split as s
    readList={}
    r1List = g('%s/*1.fastq' % (inputDir)) # get all r1.fastq
    
    for r1 in r1List:
        r1 = s(r1)[1] # trim off dir 
        r2 = r1.rstrip('1.fastq') + '2.fastq'
        readList[r1] = r2

    return readList

def searchFastq(indir, outdir, r1, r2, sequences):
    import itertools
    from Bio.Seq import Seq
    position = 1 
    plus = '+' 

    r1out = '%s/%s' %  (outdir, r1)
    r2out = '%s/%s' %  (outdir, r2)

    #write results to a new fastq file
    targetr1 = open(r1out, 'w')
    targetr2 = open(r2out, 'w')

    with open(indir+'/'+r1, 'r') as R1: 
        with open(indir+'/'+r2, 'r') as R2: 
            shouldInclude = False

            #in python2 zip reads everything into memory
            #itertools.izip is iterative, and reads line by line
            for line1, line2 in itertools.izip(R1, R2):
                if position == 1:
                    header1 = line1.rstrip('\n')
                    header2 = line2.rstrip('\n')
                    position += 1
                elif position == 2:
                    seq1 = line1.rstrip('\n') #It is necessary to first strip, or \n will count as a char
                    seq2 = line2.rstrip('\n')
                    substrings = generateSubstrings(seq1, sequences)
                    shouldInclude = checkIfTarget(substrings, sequences)
                    position += 1
                elif position == 3:
                    position += 1
                elif position == 4:
                    quality1 = line1.rstrip('\n')
                    quality2 = line2.rstrip('\n')
                    position = 1 
                    
                    if shouldInclude:
                        targetr1.write(header1 + '\n' + seq1 + '\n' + plus + '\n' + quality1 + '\n')
                        targetr2.write(header2 + '\n' + seq2 + '\n' + plus + '\n' + quality2 + '\n')
                    else:
                        pass
    targetr1.close()
    targetr2.close()
                    
def generateSubstrings(seq, sequences):
    n = len(sequences[0])
    return [seq[i:i+n] for i in range(0, len(seq)-n+1)]

def checkIfTarget(substrings, sequences):
    from Levenshtein import distance
    status = False 

    for i in substrings:
        for j in sequences:
            if distance (i,j) < 1:
                status = True
            else:
                pass

    return status

if __name__ == '__main__':
    # this includes rev complements
    sequences = [
    'AGGCCACTAGTCTATCA',
    'AAGACCGTGCCACCCAG',
    'AGTAGGAGTGACATAGA',
    'GAGTGACATAGAAGATA',
    'TATATCCATAGAAGATA',
    'CTACAAAGCTCCAGAAT',
    'GCATCAGCCGGATATCC',
    'TCTCTCACCTCCTCCAT',
    'ACACAACATACATACAA',
    'GCTCCTCAGGGGCCTGC',
    'CACTGCCCGCTGCTCTT',
    'GCTGCTCTTGGTCAAGA',
    'GGCGTAGGACGCCCAGT',
    'TAACATTGCTCTGATGT',
    'ATCTAGAAGCTGCCATC',
    'TGATAGACTAGTGGCCT',
    'CTGGGTGGCACGGTCTT',
    'TCTATGTCACTCCTACT',
    'TATCTTCTATGTCACTC',
    'TATCTTCTATGGATATA',
    'ATTCTGGAGCTTTGTAG',
    'GGATATCCGGCTGATGC',
    'ATGGAGGAGGTGAGAGA',
    'TTGTATGTATGTTGTGT',
    'GCAGGCCCCTGAGGAGC',
    'AAGAGCAGCGGGCAGTG',
    'TCTTGACCAAGAGCAGC',
    'ACTGGGCGTCCTACGCC',
    'ACATCAGAGCAATGTTA',
    'GATGGCAGCTTCTAGAT']
    
    mutSeq = [
    'AGGCCACTCGTCTATCA',
    'AAGACCGTACCACCCAG',
    'AGTAGGAGCGACATAGA',
    'GAGTGACACAGAAGATA',
    'TATATCCACAGAAGATA',
    'CTACAAAGTTCCAGAAT',
    'GCATCAGCTGGATATCC',
    'TCTCTCACTTCCTCCAT',
    'ACACAACACACATACAA',
    'GCTCCTCAAGGGCCTGC',
    'CACTGCCCACTGCTCTT',
    'GCTGCTCTCGGTCAAGA',
    'GGCGTAGGGCGCCCAGT',
    'TAACATTGTTCTGATGT',
    'ATCTAGAACCTGCCATC',
    'TGATAGACGAGTGGCCT',
    'CTGGGTGGTACGGTCTT',
    'TCTATGTCGCTCCTACT',
    'TATCTTCTGTGTCACTC',
    'TATCTTCTGTGGATATA',
    'ATTCTGGAACTTTGTAG',
    'GGATATCCAGCTGATGC',
    'ATGGAGGAAGTGAGAGA',
    'TTGTATGTGTGTTGTGT',
    'GCAGGCCCTTGAGGAGC',
    'AAGAGCAGTGGGCAGTG',
    'TCTTGACCGAGAGCAGC',
    'ACTGGGCGCCCTACGCC',
    'ACATCAGAACAATGTTA',
    'GATGGCAGGTTCTAGAT']

if __name__ == '__main__':
    indir, outdir, autoget = runArgparse()

    if autoget:
        sampleList = autogetSamples(indir)
        print sampleList

    for sample in sampleList:
        searchFastq(indir, outdir, sample, sampleList[sample], sequences)


